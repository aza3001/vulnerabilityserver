package server.vulnerable.util;

import java.io.File;
import java.util.HashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class MergeResultFiles {
	public static boolean copyXMLInfo (String from, String to) {
		if (!from.equalsIgnoreCase(to) || !(new File(from).exists())) {
			try{
				if (!(new File(to).exists())) 
					return createAndOpenTargetDoc (from, to);
				else 
					return openTargetDoc(from, to);
				
			}catch (Exception e) {
				e.printStackTrace();
				return false;
			}
			
		} else 
			return false;
		
	}
	
	private static Document parse(String path) {
		Document doc = null;
		try{
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			doc = dBuilder.parse(path);
		
		}catch (Exception e){
			e.printStackTrace();
		}
		return doc;
	}
	
	private static boolean transformInfo (Document docTo, String pathTo) {
		try{
		TransformerFactory transformerFactory = TransformerFactory.newInstance();
		Transformer transformer = transformerFactory.newTransformer();
		transformer.setOutputProperty(OutputKeys.INDENT, "yes");
		DOMSource source = new DOMSource(docTo);
		StreamResult result = new StreamResult(new File(pathTo));
		
		transformer.transform(source, result);
		}catch(Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}
	
	private static boolean openTargetDoc(String pathFrom, String pathTo) {
		Document docTo = null;
		Document docFrom = null;
		
		try{
			docTo = parse(pathTo);
			docFrom = parse(pathFrom);
		
			HashMap<String, Boolean> hmap = new HashMap<String, Boolean>();
			
			NodeList doctolist = docTo.getElementsByTagName("oval-def:definition");
			Node target = doctolist.item(0).getParentNode();
			for (int i = 0; i < doctolist.getLength(); i++) {
				System.out.println(doctolist.item(i).getAttributes().getNamedItem("id").getNodeValue());
				hmap.put(doctolist.item(i).getAttributes().getNamedItem("id").getNodeValue(), true);
			}
			
			NodeList docFromlist = docFrom.getElementsByTagName("oval-def:definition");
			for (int i = 0; i < docFromlist.getLength(); i++) {
				if (hmap.get(docFromlist.item(i).getAttributes().getNamedItem("id").getNodeValue()) == null) {
					Node n = docFromlist.item(i);
				    Node copyOfn = docTo.importNode(n, false);
				    target.appendChild(copyOfn);
				    
				    boolean affect = false;
		    		boolean ref = false;
				    NodeList meta = docFromlist.item(i).getChildNodes();				    
				    for (int j = 0; j < meta.getLength(); j++) {
				    	Node n1 = meta.item(j);
				    	if (n1.getNodeName().equalsIgnoreCase("oval-def:metadata"))
				    	{
				    		NodeList inmeta = n1.getChildNodes();
				    		for (int k = 0; k < inmeta.getLength(); k++) {
				    			if (inmeta.item(k).getNodeName().equalsIgnoreCase("oval-def:affected")){
				    				Node n2 = inmeta.item(k);
				    				System.out.println(n2.getNodeName());
				    				Node copyOfn2 = docTo.importNode(n2, true);
				    				copyOfn.appendChild(copyOfn2);
				    				affect = true;
				    			}
				    			if (inmeta.item(k).getNodeName().equalsIgnoreCase("oval-def:reference")){
				    				Node n2 = inmeta.item(k);
				    				System.out.println(n2.getNodeName());
				    				Node copyOfn2 = docTo.importNode(n2, true);
				    				copyOfn.appendChild(copyOfn2);
				    				ref = true;
				    			}
				    		}
				    	}
				    	if (affect && ref)
				    		break;
				    } 
				}
			}
			
			return transformInfo(docTo, pathTo);
				
		}catch (Exception e){
			e.printStackTrace();
			return false;
		}
	}
	
	private static boolean createAndOpenTargetDoc (String pathFrom, String pathTo) {
		Document docTo = null;
		Document docFrom = null;
		try{
			// read from new input XML file
			docFrom = parse (pathFrom);
			
			// create new output XML file
			docTo = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
			
			Element requestElement = docTo.createElementNS("www.sefcom.com", "oval-def:definitions");
			docTo.appendChild(requestElement);

			NodeList deflist = docFrom.getElementsByTagName("oval-def:definition");
			for( int i = 0; i < deflist.getLength(); i ++ ){
			    Node n = deflist.item(i);
			    Node copyOfn = docTo.importNode(n, false);
			    requestElement.appendChild(copyOfn);
			    
			    NodeList meta = deflist.item(i).getChildNodes();
			    for (int j = 0; j < meta.getLength(); j++) {
			    	Node n1 = meta.item(j);
			    	if (n1.getNodeName().equalsIgnoreCase("oval-def:metadata"))
			    	{
			    		NodeList inmeta = n1.getChildNodes();
			    		for (int k = 0; k < inmeta.getLength(); k++) {
			    			if (inmeta.item(k).getNodeName().equalsIgnoreCase("oval-def:affected")){
			    				Node n2 = inmeta.item(k);
			    				System.out.println(n2.getNodeName());
			    				Node copyOfn2 = docTo.importNode(n2, true);
			    				copyOfn.appendChild(copyOfn2);
			    			}
			    			if (inmeta.item(k).getNodeName().equalsIgnoreCase("oval-def:reference")){
			    				Node n2 = inmeta.item(k);
			    				System.out.println(n2.getNodeName());
			    				Node copyOfn2 = docTo.importNode(n2, true);
			    				copyOfn.appendChild(copyOfn2);
			    			}
			    		}
			    	}
			    }
			}
			
			return transformInfo(docTo, pathTo);
			
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	public static void main(String[] args) {
		MergeResultFiles.copyXMLInfo ("C:\\Users\\jseo15\\Desktop\\SEFCOM\\VulnerableServer\\result\\10.141.107.207\\remote-8_27_5_11.xml"
				, "C:\\Users\\jseo15\\Desktop\\SEFCOM\\VulnerableServer\\result\\10.141.107.207\\10_141_107_207.xml");
	}
}
