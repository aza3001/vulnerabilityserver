package server.vulnerable.util;

import java.awt.Color;
import java.awt.Component;
import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.util.ArrayList;
//import java.util.Vector;

import javax.swing.JProgressBar;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class OvalParser implements Runnable{
	private String path = "";
	private DefaultTableModel dtable;
	private JProgressBar jb;
	
	private ArrayList<String> arryID = new ArrayList<String>();
	
	private static boolean stop = false;
	private static boolean isRunning = false;
	
	public OvalParser(String path, DefaultTableModel dtable) {
		// TODO Auto-generated constructor stub
		stop = false;
		this.path = path;
		this.dtable = dtable;
	}
	
	public OvalParser(ArrayList<String> arryID, JProgressBar jb) {
		stop = false;
		this.arryID = arryID;
		this.jb = jb;
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		if (path != "")
			parseOVAL (path, dtable);
		else
			splitOVALByID(arryID, jb);
		
	}

	public static ArrayList<String> parseOVAL ( File file ) {
		ArrayList<String> arryID = new ArrayList<String>();
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse( file );
			doc.getDocumentElement().normalize();
			
			NodeList nlist = doc.getElementsByTagName("definition");
			
			for ( int nodeidx = 0; nodeidx < nlist.getLength(); nodeidx++ ) {
				Node n = nlist.item( nodeidx );
				
				NamedNodeMap m = n.getAttributes();
				arryID.add(m.getNamedItem("id").getTextContent());
				
				System.out.println(" id: " + m.getNamedItem("id").getTextContent());
			}
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		return arryID;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////																	     /////////////////////
	/////////////////////         this is actual work function for generate dtable_2 			 /////////////////////
	/////////////////////																		 /////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	public void parseOVAL ( String path, DefaultTableModel dtable ) {
		isRunning = true;
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse( new File(path) );
			doc.getDocumentElement().normalize();
			
			NodeList nlist = doc.getElementsByTagName("definition");
			
			for ( int nodeidx = 0; nodeidx < nlist.getLength(); nodeidx++ ) {
				Node n = nlist.item( nodeidx );
				
				NamedNodeMap m = n.getAttributes();
				
				System.out.println(" id: " + m.getNamedItem("id").getTextContent());
				
				dtable.setRowCount(nodeidx + 1);
				dtable.setValueAt(m.getNamedItem("id").getTextContent(), nodeidx, 0);
				
				arryID.add(m.getNamedItem("id").getTextContent());
				
				if (stop) { 
					path = "";
					break;
				}
			}
			
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		} finally {
			path = "";
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////																	     /////////////////////
	/////////////////////         Return IDs for split oval xml by Definition ID	 			 /////////////////////
	/////////////////////																		 /////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	public ArrayList<String> getIDs () {
		return arryID;
	}
	
	public static ArrayList<String> parseOVAL ( String path ) {
		ArrayList<String> arryID = new ArrayList<String>();
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse( new File(path) );
			doc.getDocumentElement().normalize();
			
			NodeList nlist = doc.getElementsByTagName("definition");
			
			for ( int nodeidx = 0; nodeidx < nlist.getLength(); nodeidx++ ) {
				Node n = nlist.item( nodeidx );
				
				NamedNodeMap m = n.getAttributes();
				arryID.add(m.getNamedItem("id").getTextContent());
				
				System.out.println(" id: " + m.getNamedItem("id").getTextContent());
				
				if (stop) 
					break;
			}
			
			if (stop) {
				return arryID;
			}
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		return arryID;
	}
	
	public void stopThread () {
		isRunning = false;
		stop = true;
	}
	
	public boolean isParseOvalRunning() {
		return isRunning;
	}
	
	public static boolean splitOVALByID ( ArrayList<String> arryID, JProgressBar jb ) {
		File dir = new File("runnable_file");
		
		///////////////////////////////////////////////// except existing file ////////////////////////////////////////////
		String[] list = dir.list();
		
		for (int i = 0; i < list.length; i++ ) {
			if ( arryID.contains(list[i]) )
				arryID.remove(i);
		}
		
		int total = arryID.size();
		for (int i = 0; i < arryID.size(); i++) {
			try {
				if (((int)total / 4 == i) || ((int)total /2 == i) || ((int)((total /4 ) * 3) == i))
					jb.setValue( (int)((i / total) * 100) );
				
				Process p = new ProcessBuilder("cmd", "/c", "java", "-jar", "OVAL_Splitter.jar", "-f", "oval.xml", "-id", arryID.get(i), "-o", dir.getAbsoluteFile().toString()).directory(new File ("oval_splitter")).start();
				BufferedReader in = new BufferedReader(  
	                    new InputStreamReader(p.getInputStream()));
				String line = "";
				while ((line =in.readLine())!= null) {
					System.out.println(line);
				}
				
				if (stop)
					break;
			} catch (Exception e) {
				// TODO: handle exception
				return false;
			}
			
		}
		
		return true;
	}
	
	public static void splitOVALByID ( ArrayList<String> arryID ) {
		File dir = new File("runnable_file");
		
		///////////////////////////////////////////////// except existing file ////////////////////////////////////////////
		String[] list = dir.list();
		
		for (int i = 0; i < list.length; i++ ) {
			if ( arryID.contains(list[i]) )
				arryID.remove(i);
		}
		
//		int total = arryID.size();
		for (String str : arryID) {
			try {
				Process p = new ProcessBuilder("cmd", "/c", "java", "-jar", "OVAL_Splitter.jar", "-f", "oval.xml", "-id", str, "-o", dir.getAbsoluteFile().toString()).directory(new File ("oval_splitter")).start();
				BufferedReader in = new BufferedReader(  
	                    new InputStreamReader(p.getInputStream()));
				String line = "";
				while ((line =in.readLine())!= null) {
					System.out.println(line);
				}
			} catch (Exception e) {
				// TODO: handle exception
			}
			
		}
	}
}
